#include <stdio.h>
#include <stdlib.h>
#include <string.h>


int driver(char flag[], long long vector[], int times);
int multiplication(long long M[3][3], long long vector[]);
long long scalar(long long v1[], long long v2[]);
int decrypt(char flag[], long long vector[]);


int main() {
    //INPUT
    char flag[22] = "dctf{a&({+|H/J[*Gx3|V}";
    unsigned long long vector[3] = {198438643243075ULL, 124644500865612ULL, 234337676715013ULL};
    int times = 25;
    //ENDOFINPUT

    driver(flag, vector, times);
    puts(flag);
}

int driver(char flag[], long long vector[], int times) {
    
    for (int i = times; i > 0; i--) {        
        decrypt(flag, vector);

        //finding the inverse of the matrix was done elsewhere
        long long inv[3][3] = {
            {1, 2, -2},
            {2, 1, -2},
            {-2, -2, 3}
        };
        multiplication(inv, vector);

        //if we used the wrong matrix's inverse, we simply get some of the elements as negative
        for (int i = 0; i < 3; i++) {
            if (vector[i] < 0) {
                vector[i] *= -1;
            }
        }        
        printf("(%llu, %llu, %llu)\n", vector[0], vector[1], vector[2]);
    }

}

int multiplication(long long M[3][3], long long vector[]) {
    long long result[3];
    for (int i = 0; i < 3; i++) {
        result[i] = scalar(M[i], vector);
    }

    for (int i = 0; i < 3; i++) {
        vector[i] = result[i];
    }

    return 0;     
}

long long scalar(long long v1[], long long v2[]) {
    long long sum = 0;
    for (int i = 0; i < 3; i++) {
        sum += v1[i] * v2[i];
    }
    return sum;
}

int decrypt(char flag[], long long vector[]) {
    for (int i = strlen(flag) - 2; i >= 5; i--) {
        int mic = vector[i%3] % 95;

        int chr = flag[i];
        chr -= mic; 
        if (chr < 32) {
            chr += 95;
        }
        flag[i] = chr;
    }
    return 0;
}







